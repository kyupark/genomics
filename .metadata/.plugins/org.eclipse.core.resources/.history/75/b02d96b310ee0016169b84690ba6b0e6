/*
 * ReadClipper.cpp
 *
 *  Created on: Feb 7, 2017
 *      Author: el114
 */

#include "ReadClipper.hpp"

namespace QTea {
ReadClipper::ReadClipper() {
	// TODO Auto-generated constructor stub
}
ReadClipper::~ReadClipper() {
	// TODO Auto-generated destructor stub
}

bool ReadClipper::clip_reads(string& file_name, int minimum_read_length) {
	ifstream in(file_name, ifstream::binary);
	string line;

	BamReader reader;

	if ( !reader.Open(file_name)) {
		cerr << "Could not open input BAM file" << endl;
		return false;
	}

	BamAlignment al;
	ofstream clipped_f(file_name + ".clipped_f");
	ofstream clipped_r(file_name + ".clipped_r");

	while(reader.GetNextAlignment(al)) {
		if (al.IsDuplicate()) {
			continue;
		}
		auto& refID = al.RefID;
		int64_t pos = al.Position;
		string bases = al.QueryBases;

		int64_t bases_length = bases.length();
		stringstream ss_f;
		stringstream ss_r;

		int64_t cursor = 0;
		for(std::vector<int>::size_type i = 0; i != al.CigarData.size(); ++i) {
			auto& a_cigar = al.CigarData[i];
			char& type = a_cigar.Type;
			int64_t len = a_cigar.Length;

//			stream << pos << "\t" << bases << endl;
			if (type == 'S' && len > minimum_read_length) {
				// forward
				if (!al.IsReverseStrand()){
					if (i == 0){
						ss_f << refID << ":" << pos << "\t" << bases.substr(cursor, len) << endl;
					}
				}
				// reverse
				else {
					if (i == al.CigarData.size()-1) {
						ss_r << refID << ":" << pos << "\t" << bases.substr(cursor, len) << endl;
					}
				}
			}

			cursor += len;
			pos += len;

			// checking because some reads do not have accurate cigar info
			// skip writing file
			if (cursor > bases_length) {
				break;
			}
		}

		if (cursor == bases_length) {
			clipped_f << ss_f.str();
			clipped_r << ss_r.str();
		}
	}

	clipped_f.close();
	clipped_r.close();

	return true;
}

bool ReadClipper::filter_reads(string& file_name, bool& is_forward) {
	char f_or_r;
	if (is_forward == true) {
		f_or_r = 'f';
	}
	else {
		f_or_r = 'r';
	}

	ifstream in(file_name + ".clipped_" + f_or_r, ifstream::binary);
	string line;

	while(getline(in, line)){

	}

	return true;
}


} /* namespace QT */


