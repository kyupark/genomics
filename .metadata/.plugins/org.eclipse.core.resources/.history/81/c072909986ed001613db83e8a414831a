/*
 * ReadClipper.cpp
 *
 *  Created on: Feb 7, 2017
 *      Author: el114
 */

#include "ReadClipper.hpp"

namespace QTea {
ReadClipper::ReadClipper() {
	// TODO Auto-generated constructor stub
}
ReadClipper::~ReadClipper() {
	// TODO Auto-generated destructor stub
}

bool ReadClipper::clip_reads(string& file_name) {
	ifstream in(file_name, ifstream::binary);
	string line;

	BamReader reader;

	if ( !reader.Open(file_name)) {
		cerr << "Could not open input BAM file" << endl;
		return false;
	}

	BamAlignment al;
	ofstream clipped_f(file_name + ".clipped_f");
	ofstream clipped_r(file_name + ".clipped_r");

	while(reader.GetNextAlignment(al)) {
		int64_t pos = al.Position;
		string bases = al.QueryBases;
		int64_t bases_length = bases.length();
		stringstream ss_f;
		stringstream ss_r;

		int64_t cursor = 0;
		for(std::vector<int>::size_type i = 0; i != al.CigarData.size(); ++i) {
			auto& a_cigar = al.CigarData[i];
			char& type = a_cigar.Type;
			int64_t len = a_cigar.Length;

//			stream << pos << "\t" << bases << endl;

			if (type == 'S') {
				if (!al.IsReverseStrand()){
					if (i != 0){
						ss_f << pos << "\t" << pos + len - 1 << "\t";
						ss_f << bases.substr(cursor, len) << endl;
					}
				}
				else {
					if (i != al.CigarData.size()) {
						ss_r << pos << "\t" << pos + len - 1 << "\t";
						ss_r << bases.substr(cursor, len) << endl;
					}
				}
			}

			cursor += len;
			pos += len;

			if (cursor > bases_length) {
				break;
			}
		}

		if (cursor == bases_length) {
			clipped_f << ss_f.str();
			clipped_r << ss_r.str();
		}
	}

	clipped_f.close();
	clipped_r.close();

	return true;
}

bool ReadClipper::filter_f_reads(string& file_name) {
	ifstream in(file_name+".clipped_f", ifstream::binary);
	string line;
}


} /* namespace QT */


